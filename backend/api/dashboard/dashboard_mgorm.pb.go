// Code generated by protoc-gen-mgorm. DO NOT EDIT.
// Desc:
package dashboard

import (
	"context"
	"fmt"
	"time"

	"github.com/995933447/mgorm"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

const (
	UserDbName   = "mconfigcenter_dashboard"
	UserTbName   = "user"
	UserConnName = "default"
)

// 索引
var userIndexKeys = []string{}

var userUniqueIndexKeys = []string{
	"username",
	"user_id",
}

var userExpireIndexKeys = []string{}

type UserOrm struct {
	ID          primitive.ObjectID `json:"_id,omitempty" bson:"_id,omitempty"`
	Username    string             `json:"username" bson:"username"`
	Password    string             `json:"password" bson:"password"`
	Status      uint32             `json:"status" bson:"status"`
	UserId      uint64             `json:"user_id" bson:"user_id"`
	LastLoginAt int64              `json:"last_login_at" bson:"last_login_at"`
	RoleIds     []uint64           `json:"role_ids" bson:"role_ids"`
	CreatedAt   time.Time          `json:"created_at,omitempty" bson:"created_at,omitempty"`
	UpdatedAt   time.Time          `json:"updated_at,omitempty" bson:"updated_at,omitempty"`
}

var userOrmCache mgorm.Cache

func SetUserOrmCache(cache mgorm.Cache) {
	userOrmCache = cache
}

var onUserOrmQueryDone mgorm.OnQueryDoneFunc

func SetUserOrmOnQueryDone(fn mgorm.OnQueryDoneFunc) {
	onUserOrmQueryDone = fn
}

func NewUserModel() *UserModel {
	cache := userOrmCache
	if cache == nil {
		cache = mgorm.DefaultCache
	}
	orm := mgorm.NewOrm(
		UserConnName,
		UserDbName,
		UserTbName,
		true,
		cache,
		userIndexKeys,
		userUniqueIndexKeys,
		userExpireIndexKeys,
	)
	onQueryDoneFunc := onUserOrmQueryDone
	if onQueryDoneFunc == nil {
		onQueryDoneFunc = mgorm.OnQueryDone
	}
	orm.SetOnQueryDone(onQueryDoneFunc)
	return &UserModel{
		Model: mgorm.Model[UserOrm]{
			Orm:    orm,
			Cached: true,
		},
	}
}

type UserModel struct {
	mgorm.Model[UserOrm]
}

func (m *UserModel) NormalizeOrmForInsert(data *UserOrm) {
	if data.ID.IsZero() {
		data.ID = primitive.NewObjectID()
	}
	if data.CreatedAt.IsZero() {
		data.CreatedAt = time.Now()
	}
	data.UpdatedAt = data.CreatedAt
}

func (m *UserModel) InsertOneIgnoreConflict(ctx context.Context, data *UserOrm) error {
	m.NormalizeOrmForInsert(data)
	_, err := m.Model.InsertOneIgnoreConflict(ctx, data)
	return err
}

func (m *UserModel) InsertOne(ctx context.Context, data *UserOrm) error {
	m.NormalizeOrmForInsert(data)
	_, err := m.Model.InsertOne(ctx, data)
	return err
}

func (m *UserModel) InsertMany(ctx context.Context, dataList []*UserOrm) error {
	var ins []any
	for _, data := range dataList {
		m.NormalizeOrmForInsert(data)
		ins = append(ins, data)
	}
	_, err := m.Model.InsertMany(ctx, ins)
	return err
}

func (m *UserModel) GetCacheKeys(data *UserOrm) []string {
	var cacheKeys []string
	cacheKeys = append(cacheKeys, fmt.Sprintf("_id:%s", data.ID.Hex()))
	cacheKeys = append(cacheKeys, fmt.Sprintf(
		"username:%s", data.Username,
	))
	cacheKeys = append(cacheKeys, fmt.Sprintf(
		"user_id:%d", data.UserId,
	))
	return cacheKeys
}

func (m *UserModel) Update(ctx context.Context, data *UserOrm) (*mongo.UpdateResult, error) {
	dataB, err := mgorm.ToBsonM(data)
	if err != nil {
		return nil, err
	}
	old, err := m.Model.FindOneByID(ctx, data.ID.Hex())
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}
	dataB["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, bson.M{"_id": dataB["_id"]}, bson.M{"$set": dataB})
}

func (m *UserModel) UpdateOne(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	old, err := m.Model.FindOne(ctx, filter)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}
	data["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, filter, bson.M{"$set": data})
}

func (m *UserModel) UpdateMany(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	list, err := m.Model.FindAll(ctx, filter)
	if err != nil {
		return nil, err
	}
	if len(list) > 0 {
		var cacheKeys []string
		for _, item := range list {
			cacheKeys = append(cacheKeys, m.GetCacheKeys(item)...)
		}
		defer m.Model.DelCache(cacheKeys)
	}
	data["updated_at"] = time.Now()
	return m.Model.UpdateMany(ctx, filter, bson.M{"$set": data})
}

func (m *UserModel) Upsert(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	data["updated_at"] = time.Now()
	insertData["created_at"] = time.Now()
	old, err := m.Model.FindOne(ctx, filter)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}

	return m.Model.Upsert(ctx, filter, bson.M{"$set": data, "$setOnInsert": insertData})
}

func (m *UserModel) UpInc(ctx context.Context, filter any, data bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	insertData["created_at"] = time.Now()
	old, err := m.Model.FindOne(ctx, filter)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}

	return m.Model.Upsert(ctx, filter, bson.M{"$inc": data, "$set": bson.M{"updated_at": time.Now()}, "$setOnInsert": insertData})
}

func (m *UserModel) UpAndInc(ctx context.Context, filter any, data, incdata bson.M) (*mongo.UpdateResult, error) {
	insertData := bson.M{}
	data["updated_at"] = time.Now()
	insertData["created_at"] = time.Now()
	old, err := m.Model.FindOne(ctx, filter)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}

	return m.Model.Upsert(ctx, filter, bson.M{"$set": data, "$inc": incdata, "$setOnInsert": insertData})
}

func (m *UserModel) DeleteOne(ctx context.Context, filter any) (*mongo.DeleteResult, error) {
	old, err := m.Model.FindOne(ctx, filter)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}
	return m.Model.DeleteOne(ctx, filter)
}

func (m *UserModel) DeleteMany(ctx context.Context, filter any) (*mongo.DeleteResult, error) {
	list, err := m.Model.FindAll(ctx, filter)
	if err != nil {
		return nil, err
	}
	if len(list) > 0 {
		var cacheKeys []string
		for _, item := range list {
			cacheKeys = append(cacheKeys, m.GetCacheKeys(item)...)
		}
		defer m.Model.DelCache(cacheKeys)
	}
	return m.Model.DeleteMany(ctx, filter)
}

func (m *UserModel) UpdateOneByID(ctx context.Context, id string, data bson.M) (*mongo.UpdateResult, error) {
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	old, err := m.Model.FindOneByID(ctx, id)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}
	data["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, bson.M{"_id": objId}, bson.M{"$set": data})
}

func (m *UserModel) DeleteOneByID(ctx context.Context, id string) (*mongo.DeleteResult, error) {
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	old, err := m.Model.FindOneByID(ctx, id)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(old))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}

	return m.Model.DeleteOne(ctx, bson.M{"_id": objId})
}

func (m *UserModel) FindOneByID(ctx context.Context, id string) (*UserOrm, error) {
	var data UserOrm
	objId, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, err
	}
	filter := bson.M{"_id": objId}
	cacheKey := fmt.Sprintf("_id:%s", id)
	err = m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err != nil {
		return nil, err
	}
	return &data, nil
}

func (m *UserModel) UpdateOneByUsername(ctx context.Context, username string, update bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	var data UserOrm
	filter["username"] = username
	cacheKey := fmt.Sprintf(
		"username:%s",
		username,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}

	update["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, filter, bson.M{"$set": update})
}

func (m *UserModel) FindOneByUsername(ctx context.Context, username string) (*UserOrm, error) {
	var data UserOrm
	filter := bson.M{}
	filter["username"] = username
	cacheKey := fmt.Sprintf(
		"username:%s",
		username,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err != nil {
		return nil, err
	}
	return &data, nil
}

func (m *UserModel) DeleteOneByUsername(ctx context.Context, username string) (*mongo.DeleteResult, error) {
	var data UserOrm
	filter := bson.M{}
	filter["username"] = username
	cacheKey := fmt.Sprintf(
		"username:%s",
		username,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}
	return m.Model.DeleteOne(ctx, filter)
}

func (m *UserModel) UpdateOneByUserId(ctx context.Context, userId uint64, update bson.M) (*mongo.UpdateResult, error) {
	filter := bson.M{}
	var data UserOrm
	filter["user_id"] = userId
	cacheKey := fmt.Sprintf(
		"user_id:%d",
		userId,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}

	update["updated_at"] = time.Now()
	return m.Model.UpdateOne(ctx, filter, bson.M{"$set": update})
}

func (m *UserModel) FindOneByUserId(ctx context.Context, userId uint64) (*UserOrm, error) {
	var data UserOrm
	filter := bson.M{}
	filter["user_id"] = userId
	cacheKey := fmt.Sprintf(
		"user_id:%d",
		userId,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err != nil {
		return nil, err
	}
	return &data, nil
}

func (m *UserModel) DeleteOneByUserId(ctx context.Context, userId uint64) (*mongo.DeleteResult, error) {
	var data UserOrm
	filter := bson.M{}
	filter["user_id"] = userId
	cacheKey := fmt.Sprintf(
		"user_id:%d",
		userId,
	)
	err := m.Model.FindOneByCacheKey(ctx, filter, cacheKey, &data)
	if err == nil {
		defer m.Model.DelCache(m.GetCacheKeys(&data))
	} else if err != mongo.ErrNoDocuments {
		return nil, err
	}
	return m.Model.DeleteOne(ctx, filter)
}
